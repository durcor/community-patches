From a67a8603aa6a357606161f74c84569b8100b7085 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 16 Apr 2020 15:46:24 +0200
Subject: [PATCH 01/15] [spirv] Cache basic types instead of looking them up

---
 src/spirv/spirv_module.cpp | 144 +++++++++++++++++++++++++++++--------
 src/spirv/spirv_module.h   |  26 +++++++
 2 files changed, 141 insertions(+), 29 deletions(-)

diff --git a/src/spirv/spirv_module.cpp b/src/spirv/spirv_module.cpp
index 0c005d460..817372622 100644
--- a/src/spirv/spirv_module.cpp
+++ b/src/spirv/spirv_module.cpp
@@ -648,12 +648,14 @@ namespace dxvk {
   
   
   uint32_t SpirvModule::defVoidType() {
-    return this->defType(spv::OpTypeVoid, 0, nullptr);
+    return this->defTypeCached(m_typeVoid,
+      spv::OpTypeVoid, 0, nullptr);
   }
   
   
   uint32_t SpirvModule::defBoolType() {
-    return this->defType(spv::OpTypeBool, 0, nullptr);
+    return this->defTypeCached(m_typeBool[0],
+      spv::OpTypeBool, 0, nullptr);
   }
   
   
@@ -661,6 +663,32 @@ namespace dxvk {
           uint32_t                width,
           uint32_t                isSigned) {
     std::array<uint32_t, 2> args = {{ width, isSigned }};
+    switch ((int64_t)width * (isSigned ? -1 : 1)) {
+    case -64:
+      return this->defTypeCached(m_typeSInt64[0],
+        spv::OpTypeInt, args.size(), args.data());
+    case -32:
+      return this->defTypeCached(m_typeSInt32[0],
+        spv::OpTypeInt, args.size(), args.data());
+    case -16:
+      return this->defTypeCached(m_typeSInt16[0],
+        spv::OpTypeInt, args.size(), args.data());
+    case -8:
+      return this->defTypeCached(m_typeSInt8[0],
+        spv::OpTypeInt, args.size(), args.data());
+    case +8:
+      return this->defTypeCached(m_typeUInt8[0],
+        spv::OpTypeInt, args.size(), args.data());
+    case +16:
+      return this->defTypeCached(m_typeUInt16[0],
+        spv::OpTypeInt, args.size(), args.data());
+    case +32:
+      return this->defTypeCached(m_typeUInt32[0],
+        spv::OpTypeInt, args.size(), args.data());
+    case +64:
+      return this->defTypeCached(m_typeUInt64[0],
+        spv::OpTypeInt, args.size(), args.data());
+    }
     return this->defType(spv::OpTypeInt,
       args.size(), args.data());
   }
@@ -669,6 +697,17 @@ namespace dxvk {
   uint32_t SpirvModule::defFloatType(
           uint32_t                width) {
     std::array<uint32_t, 1> args = {{ width }};
+    switch (width) {
+    case 16:
+      return this->defTypeCached(m_typeFloat16[0],
+        spv::OpTypeFloat, args.size(), args.data());
+    case 32:
+      return this->defTypeCached(m_typeFloat32[0],
+        spv::OpTypeFloat, args.size(), args.data());
+    case 64:
+      return this->defTypeCached(m_typeFloat64[0],
+        spv::OpTypeFloat, args.size(), args.data());
+    }
     return this->defType(spv::OpTypeFloat,
       args.size(), args.data());
   }
@@ -679,6 +718,43 @@ namespace dxvk {
           uint32_t                elementCount) {
     std::array<uint32_t, 2> args =
       {{ elementType, elementCount }};
+
+    if (elementType == m_typeBool[0])
+      return this->defTypeCached(m_typeBool[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeSInt8[0])
+      return this->defTypeCached(m_typeSInt8[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeSInt16[0])
+      return this->defTypeCached(m_typeSInt16[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeSInt32[0])
+      return this->defTypeCached(m_typeSInt32[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeSInt64[0])
+      return this->defTypeCached(m_typeSInt64[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeUInt8[0])
+      return this->defTypeCached(m_typeUInt8[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeUInt16[0])
+      return this->defTypeCached(m_typeUInt16[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeUInt32[0])
+      return this->defTypeCached(m_typeUInt32[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeUInt64[0])
+      return this->defTypeCached(m_typeUInt64[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeFloat16[0])
+      return this->defTypeCached(m_typeFloat16[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeFloat32[0])
+      return this->defTypeCached(m_typeFloat32[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
+    else if (elementType == m_typeFloat64[0])
+      return this->defTypeCached(m_typeFloat64[elementCount - 1],
+          spv::OpTypeVector, args.size(), args.data());
     
     return this->defType(spv::OpTypeVector,
       args.size(), args.data());
@@ -709,13 +785,10 @@ namespace dxvk {
   uint32_t SpirvModule::defArrayTypeUnique(
           uint32_t                typeId,
           uint32_t                length) {
-    uint32_t resultId = this->allocateId();
+    std::array<uint32_t, 2> args = {{ typeId, length }};
     
-    m_typeConstDefs.putIns (spv::OpTypeArray, 4);
-    m_typeConstDefs.putWord(resultId);
-    m_typeConstDefs.putWord(typeId);
-    m_typeConstDefs.putWord(length);
-    return resultId;
+    return this->defTypeUnique(spv::OpTypeArray,
+      args.size(), args.data());
   }
   
   
@@ -730,12 +803,10 @@ namespace dxvk {
   
   uint32_t SpirvModule::defRuntimeArrayTypeUnique(
           uint32_t                typeId) {
-    uint32_t resultId = this->allocateId();
+    std::array<uint32_t, 1> args = { typeId };
     
-    m_typeConstDefs.putIns (spv::OpTypeRuntimeArray, 3);
-    m_typeConstDefs.putWord(resultId);
-    m_typeConstDefs.putWord(typeId);
-    return resultId;
+    return this->defTypeUnique(spv::OpTypeRuntimeArray,
+      args.size(), args.data());
   }
   
   
@@ -765,14 +836,8 @@ namespace dxvk {
   uint32_t SpirvModule::defStructTypeUnique(
           uint32_t                memberCount,
     const uint32_t*               memberTypes) {
-    uint32_t resultId = this->allocateId();
-    
-    m_typeConstDefs.putIns (spv::OpTypeStruct, 2 + memberCount);
-    m_typeConstDefs.putWord(resultId);
-    
-    for (uint32_t i = 0; i < memberCount; i++)
-      m_typeConstDefs.putWord(memberTypes[i]);
-    return resultId;
+    return this->defTypeUnique(spv::OpTypeStruct,
+      memberCount, memberTypes);
   }
   
   
@@ -790,7 +855,8 @@ namespace dxvk {
   
   
   uint32_t SpirvModule::defSamplerType() {
-    return this->defType(spv::OpTypeSampler, 0, nullptr);
+    return this->defTypeCached(m_typeSampler,
+      spv::OpTypeSampler, 0, nullptr);
   }
   
   
@@ -3515,6 +3581,32 @@ namespace dxvk {
       m_code.putWord(streamId);
     }
   }
+
+
+  uint32_t SpirvModule::defTypeCached(
+          std::optional<uint32_t>&cache,
+          spv::Op                 op,
+          uint32_t                argCount,
+    const uint32_t*               argIds) {
+    if (!cache)
+      cache = this->defTypeUnique(op, argCount,
+        argIds);
+    return *cache;
+  }
+
+
+  uint32_t SpirvModule::defTypeUnique(
+          spv::Op                 op,
+          uint32_t                argCount,
+    const uint32_t*               argIds) {
+    uint32_t resultId = this->allocateId();
+    m_typeConstDefs.putIns (op, 2 + argCount);
+    m_typeConstDefs.putWord(resultId);
+
+    for (uint32_t i = 0; i < argCount; i++)
+      m_typeConstDefs.putWord(argIds[i]);
+    return resultId;
+  }
   
   
   uint32_t SpirvModule::defType(
@@ -3536,13 +3628,7 @@ namespace dxvk {
     }
     
     // Type not yet declared, create a new one.
-    uint32_t resultId = this->allocateId();
-    m_typeConstDefs.putIns (op, 2 + argCount);
-    m_typeConstDefs.putWord(resultId);
-    
-    for (uint32_t i = 0; i < argCount; i++)
-      m_typeConstDefs.putWord(argIds[i]);
-    return resultId;
+    return this->defTypeUnique(op, argCount, argIds);
   }
   
   
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index b17b848e0..81825d7e6 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -1225,8 +1225,34 @@ namespace dxvk {
     SpirvCodeBuffer m_variables;
     SpirvCodeBuffer m_code;
 
+    std::optional<uint32_t> m_typeVoid;
+    std::optional<uint32_t> m_typeSampler;
+    std::optional<uint32_t> m_typeBool[4];
+    std::optional<uint32_t> m_typeSInt8[4];
+    std::optional<uint32_t> m_typeSInt16[4];
+    std::optional<uint32_t> m_typeSInt32[4];
+    std::optional<uint32_t> m_typeSInt64[4];
+    std::optional<uint32_t> m_typeUInt8[4];
+    std::optional<uint32_t> m_typeUInt16[4];
+    std::optional<uint32_t> m_typeUInt32[4];
+    std::optional<uint32_t> m_typeUInt64[4];
+    std::optional<uint32_t> m_typeFloat16[4];
+    std::optional<uint32_t> m_typeFloat32[4];
+    std::optional<uint32_t> m_typeFloat64[4];
+
     std::unordered_set<uint32_t> m_lateConsts;
+
+    uint32_t defTypeCached(
+            std::optional<uint32_t>&cache,
+            spv::Op                 op,
+            uint32_t                argCount,
+      const uint32_t*               argIds);
     
+    uint32_t defTypeUnique(
+            spv::Op                 op,
+            uint32_t                argCount,
+      const uint32_t*               argIds);
+
     uint32_t defType(
             spv::Op                 op, 
             uint32_t                argCount,

From 3c409db63db4f406988d0f7af7aa2e3cd2c9b63b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 16 Apr 2020 16:44:23 +0200
Subject: [PATCH 02/15] [spirv] Cache basic constants intead of looking them up

---
 src/spirv/spirv_module.cpp | 101 +++++++++++++++++++++++++++++--------
 src/spirv/spirv_module.h   |  22 ++++++++
 2 files changed, 103 insertions(+), 20 deletions(-)

diff --git a/src/spirv/spirv_module.cpp b/src/spirv/spirv_module.cpp
index 817372622..ad4c3ca02 100644
--- a/src/spirv/spirv_module.cpp
+++ b/src/spirv/spirv_module.cpp
@@ -178,89 +178,123 @@ namespace dxvk {
   
   uint32_t SpirvModule::constBool(
           bool                    v) {
-    return this->defConst(v
-        ? spv::OpConstantTrue
-        : spv::OpConstantFalse,
-      this->defBoolType(),
-      0, nullptr);
+    return this->defConstCached(m_constBool[v ? 1 : 0],
+      v ? spv::OpConstantTrue : spv::OpConstantFalse,
+      this->defBoolType(), 0, nullptr);
   }
   
   
   uint32_t SpirvModule::consti32(
           int32_t                 v) {
+    auto it = m_constSInt32.find(v);
+    if (it != m_constSInt32.end()) return it->second;
+
     std::array<uint32_t, 1> data;
     std::memcpy(data.data(), &v, sizeof(v));
     
-    return this->defConst(
+    auto id = this->defConstUnique(
       spv::OpConstant,
       this->defIntType(32, 1),
       data.size(),
       data.data());
+
+    m_constSInt32[v] = id;
+    return id;
   }
   
   
   uint32_t SpirvModule::consti64(
           int64_t                 v) {
+    auto it = m_constSInt64.find(v);
+    if (it != m_constSInt64.end()) return it->second;
+
     std::array<uint32_t, 2> data;
     std::memcpy(data.data(), &v, sizeof(v));
     
-    return this->defConst(
+    auto id = this->defConstUnique(
       spv::OpConstant,
       this->defIntType(64, 1),
       data.size(),
       data.data());
+
+    m_constSInt64[v] = id;
+    return id;
   }
   
   
   uint32_t SpirvModule::constu32(
           uint32_t                v) {
+    auto it = m_constUInt32.find(v);
+    if (it != m_constUInt32.end()) return it->second;
+
     std::array<uint32_t, 1> data;
     std::memcpy(data.data(), &v, sizeof(v));
     
-    return this->defConst(
+    auto id = this->defConstUnique(
       spv::OpConstant,
       this->defIntType(32, 0),
       data.size(),
       data.data());
+
+    m_constUInt32[v] = id;
+    return id;
   }
   
   
   uint32_t SpirvModule::constu64(
           uint64_t                v) {
+    auto it = m_constUInt64.find(v);
+    if (it != m_constUInt64.end()) return it->second;
+
     std::array<uint32_t, 2> data;
     std::memcpy(data.data(), &v, sizeof(v));
     
-    return this->defConst(
+    auto id = this->defConstUnique(
       spv::OpConstant,
       this->defIntType(64, 0),
       data.size(),
       data.data());
+
+    m_constUInt64[v] = id;
+    return id;
   }
   
   
   uint32_t SpirvModule::constf32(
           float                   v) {
+    auto it = m_constFloat32.find(v);
+    if (it != m_constFloat32.end()) return it->second;
+
     std::array<uint32_t, 1> data;
     std::memcpy(data.data(), &v, sizeof(v));
     
-    return this->defConst(
+    auto id = this->defConstUnique(
       spv::OpConstant,
       this->defFloatType(32),
       data.size(),
       data.data());
+
+    m_constFloat32[v] = id;
+    return id;
   }
   
   
   uint32_t SpirvModule::constf64(
           double                  v) {
+    auto it = m_constFloat64.find(v);
+    if (it != m_constFloat64.end()) return it->second;
+
     std::array<uint32_t, 2> data;
     std::memcpy(data.data(), &v, sizeof(v));
     
-    return this->defConst(
+    auto id = this->defConstUnique(
       spv::OpConstant,
       this->defFloatType(64),
       data.size(),
       data.data());
+
+    m_constFloat64[v] = id;
+    return id;
   }
   
   
@@ -410,8 +444,13 @@ namespace dxvk {
   
   uint32_t SpirvModule::constUndef(
           uint32_t                typeId) {
-    return this->defConst(spv::OpUndef,
+    auto it = m_constUndef.find(typeId);
+    if (it != m_constUndef.end()) return it->second;
+
+    auto id = this->defConstUnique(spv::OpUndef,
       typeId, 0, nullptr);
+    m_constUndef[typeId] = id;
+    return id;
   }
 
 
@@ -3632,6 +3671,35 @@ namespace dxvk {
   }
   
   
+  uint32_t SpirvModule::defConstCached(
+          std::optional<uint32_t>&cache,
+          spv::Op                 op,
+          uint32_t                typeId,
+          uint32_t                argCount,
+    const uint32_t*               argIds) {
+    if (!cache)
+      cache = this->defConstUnique(op, typeId,
+        argCount, argIds);
+    return *cache;
+  }
+
+
+  uint32_t SpirvModule::defConstUnique(
+          spv::Op                 op,
+          uint32_t                typeId,
+          uint32_t                argCount,
+    const uint32_t*               argIds) {
+    uint32_t resultId = this->allocateId();
+    m_typeConstDefs.putIns (op, 3 + argCount);
+    m_typeConstDefs.putWord(typeId);
+    m_typeConstDefs.putWord(resultId);
+    
+    for (uint32_t i = 0; i < argCount; i++)
+      m_typeConstDefs.putWord(argIds[i]);
+    return resultId;
+  }
+
+
   uint32_t SpirvModule::defConst(
           spv::Op                 op,
           uint32_t                typeId,
@@ -3656,14 +3724,7 @@ namespace dxvk {
     }
     
     // Constant not yet declared, make a new one
-    uint32_t resultId = this->allocateId();
-    m_typeConstDefs.putIns (op, 3 + argCount);
-    m_typeConstDefs.putWord(typeId);
-    m_typeConstDefs.putWord(resultId);
-    
-    for (uint32_t i = 0; i < argCount; i++)
-      m_typeConstDefs.putWord(argIds[i]);
-    return resultId;
+    return this->defConstUnique(op, typeId, argCount, argIds);
   }
   
   
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index 81825d7e6..e839ce669 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -1240,6 +1240,15 @@ namespace dxvk {
     std::optional<uint32_t> m_typeFloat32[4];
     std::optional<uint32_t> m_typeFloat64[4];
 
+    std::optional<uint32_t>                m_constBool[2];
+    std::unordered_map<uint32_t, uint32_t> m_constUndef;
+    std::unordered_map<int32_t, uint32_t>  m_constSInt32;
+    std::unordered_map<int64_t, uint32_t>  m_constSInt64;
+    std::unordered_map<uint32_t, uint32_t> m_constUInt32;
+    std::unordered_map<uint64_t, uint32_t> m_constUInt64;
+    std::unordered_map<float, uint32_t>    m_constFloat32;
+    std::unordered_map<double, uint32_t>   m_constFloat64;
+
     std::unordered_set<uint32_t> m_lateConsts;
 
     uint32_t defTypeCached(
@@ -1258,6 +1267,19 @@ namespace dxvk {
             uint32_t                argCount,
       const uint32_t*               argIds);
     
+    uint32_t defConstCached(
+            std::optional<uint32_t>&cache,
+            spv::Op                 op,
+            uint32_t                typeId,
+            uint32_t                argCount,
+      const uint32_t*               argIds);
+
+    uint32_t defConstUnique(
+            spv::Op                 op,
+            uint32_t                typeId,
+            uint32_t                argCount,
+      const uint32_t*               argIds);
+
     uint32_t defConst(
             spv::Op                 op,
             uint32_t                typeId,

From 1da53e4b7aa76f81c301c3d3f7bb7abdd4e69e2b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 6 May 2020 20:11:05 +0200
Subject: [PATCH 03/15] [spirv] Track type locations instead of checking the
 whole buffer

---
 src/spirv/spirv_module.cpp | 19 ++++++++++---------
 src/spirv/spirv_module.h   |  2 ++
 2 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/src/spirv/spirv_module.cpp b/src/spirv/spirv_module.cpp
index ad4c3ca02..9967226e0 100644
--- a/src/spirv/spirv_module.cpp
+++ b/src/spirv/spirv_module.cpp
@@ -826,6 +826,7 @@ namespace dxvk {
           uint32_t                length) {
     std::array<uint32_t, 2> args = {{ typeId, length }};
     
+    m_typeLocs.push_back(m_typeConstDefs.getInsertionPtr());
     return this->defTypeUnique(spv::OpTypeArray,
       args.size(), args.data());
   }
@@ -844,6 +845,7 @@ namespace dxvk {
           uint32_t                typeId) {
     std::array<uint32_t, 1> args = { typeId };
     
+    m_typeLocs.push_back(m_typeConstDefs.getInsertionPtr());
     return this->defTypeUnique(spv::OpTypeRuntimeArray,
       args.size(), args.data());
   }
@@ -875,6 +877,7 @@ namespace dxvk {
   uint32_t SpirvModule::defStructTypeUnique(
           uint32_t                memberCount,
     const uint32_t*               memberTypes) {
+    m_typeLocs.push_back(m_typeConstDefs.getInsertionPtr());
     return this->defTypeUnique(spv::OpTypeStruct,
       memberCount, memberTypes);
   }
@@ -3655,18 +3658,16 @@ namespace dxvk {
     // Since the type info is stored in the code buffer,
     // we can use the code buffer to look up type IDs as
     // well. Result IDs are always stored as argument 1.
-    for (auto ins : m_typeConstDefs) {
-      bool match = ins.opCode() == op
-                && ins.length() == 2 + argCount;
-      
-      for (uint32_t i = 0; i < argCount && match; i++)
-        match &= ins.arg(2 + i) == argIds[i];
-      
-      if (match)
-        return ins.arg(1);
+    const uint32_t *data = m_typeConstDefs.data();
+    for (auto i : m_typeLocs) {
+      if ((data[i] & spv::OpCodeMask) == op &&
+          (data[i] >> spv::WordCountShift) == (2 + argCount) &&
+          (!argCount || !std::memcmp(data + i + 2, argIds, argCount * sizeof(uint32_t))))
+        return data[i + 1];
     }
     
     // Type not yet declared, create a new one.
+    m_typeLocs.push_back(m_typeConstDefs.getInsertionPtr());
     return this->defTypeUnique(op, argCount, argIds);
   }
   
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index e839ce669..00cea727d 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -1225,6 +1225,8 @@ namespace dxvk {
     SpirvCodeBuffer m_variables;
     SpirvCodeBuffer m_code;
 
+    std::vector<size_t> m_typeLocs;
+
     std::optional<uint32_t> m_typeVoid;
     std::optional<uint32_t> m_typeSampler;
     std::optional<uint32_t> m_typeBool[4];

From 3166b99ec5609f310c97e556a00710e71911d32e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 16 Apr 2020 16:44:23 +0200
Subject: [PATCH 04/15] [spirv] Track const locations instead of checking the
 whole buffer

---
 src/spirv/spirv_module.cpp | 24 +++++++++---------------
 src/spirv/spirv_module.h   |  1 +
 2 files changed, 10 insertions(+), 15 deletions(-)

diff --git a/src/spirv/spirv_module.cpp b/src/spirv/spirv_module.cpp
index 9967226e0..cf2d17334 100644
--- a/src/spirv/spirv_module.cpp
+++ b/src/spirv/spirv_module.cpp
@@ -3707,24 +3707,18 @@ namespace dxvk {
           uint32_t                argCount,
     const uint32_t*               argIds) {
     // Avoid declaring constants multiple times
-    for (auto ins : m_typeConstDefs) {
-      bool match = ins.opCode() == op
-                && ins.length() == 3 + argCount
-                && ins.arg(1)   == typeId;
-      
-      for (uint32_t i = 0; i < argCount && match; i++)
-        match &= ins.arg(3 + i) == argIds[i];
-      
-      if (!match)
-        continue;
-      
-      uint32_t id = ins.arg(2);
-
-      if (m_lateConsts.find(id) == m_lateConsts.end())
-        return id;
+    const uint32_t *data = m_typeConstDefs.data();
+    for (auto i : m_constLocs) {
+      if ((data[i] & spv::OpCodeMask) == op &&
+          (data[i] >> spv::WordCountShift) == (3 + argCount) &&
+          data[i + 1] == typeId &&
+          (!argCount || !std::memcmp(data + i + 3, argIds, argCount * sizeof(uint32_t))) &&
+          m_lateConsts.find(data[i + 2]) == m_lateConsts.end())
+        return data[i + 2];
     }
     
     // Constant not yet declared, make a new one
+    m_constLocs.push_back(m_typeConstDefs.getInsertionPtr());
     return this->defConstUnique(op, typeId, argCount, argIds);
   }
   
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index 00cea727d..9ef481897 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -1226,6 +1226,7 @@ namespace dxvk {
     SpirvCodeBuffer m_code;
 
     std::vector<size_t> m_typeLocs;
+    std::vector<size_t> m_constLocs;
 
     std::optional<uint32_t> m_typeVoid;
     std::optional<uint32_t> m_typeSampler;

From 3bef2d7bfebb479e1b2c5a5f2390b5fbf49a428d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 16 Apr 2020 17:53:58 +0200
Subject: [PATCH 05/15] [spirv] Track late const locations instead of looking
 them up

---
 src/spirv/spirv_module.cpp | 19 ++++++-------------
 src/spirv/spirv_module.h   |  2 +-
 2 files changed, 7 insertions(+), 14 deletions(-)

diff --git a/src/spirv/spirv_module.cpp b/src/spirv/spirv_module.cpp
index cf2d17334..b66823985 100644
--- a/src/spirv/spirv_module.cpp
+++ b/src/spirv/spirv_module.cpp
@@ -457,7 +457,7 @@ namespace dxvk {
   uint32_t SpirvModule::lateConst32(
           uint32_t                typeId) {
     uint32_t resultId = this->allocateId();
-    m_lateConsts.insert(resultId);
+    m_lateConsts[resultId] = m_typeConstDefs.getInsertionPtr();
 
     m_typeConstDefs.putIns (spv::OpConstant, 4);
     m_typeConstDefs.putWord(typeId);
@@ -470,19 +470,12 @@ namespace dxvk {
   void SpirvModule::setLateConst(
             uint32_t                constId,
       const uint32_t*               argIds) {
-    for (auto ins : m_typeConstDefs) {
-      if (ins.opCode() != spv::OpConstant
-       && ins.opCode() != spv::OpConstantComposite)
-        continue;
-      
-      if (ins.arg(2) != constId)
-        continue;
-
-      for (uint32_t i = 3; i < ins.length(); i++)
-        ins.setArg(i, argIds[i - 3]);
+    auto ins = SpirvInstruction(m_typeConstDefs.data(),
+                                m_lateConsts[constId],
+                                m_typeConstDefs.dwords());
 
-      return;
-    }
+    for (uint32_t i = 3; i < ins.length(); i++)
+      ins.setArg(i, argIds[i - 3]);
   }
 
 
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index 9ef481897..a453f2740 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -1252,7 +1252,7 @@ namespace dxvk {
     std::unordered_map<float, uint32_t>    m_constFloat32;
     std::unordered_map<double, uint32_t>   m_constFloat64;
 
-    std::unordered_set<uint32_t> m_lateConsts;
+    std::unordered_map<uint32_t, size_t> m_lateConsts;
 
     uint32_t defTypeCached(
             std::optional<uint32_t>&cache,

From 7cf64f9d70b2fd0b1216381e0ac502aaec96f817 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 14 Apr 2020 23:44:10 +0200
Subject: [PATCH 06/15] [spirv] Use simpler and faster compression method

This uses variable length integer coding with one continuation bit per
byte.
---
 src/spirv/spirv_compression.cpp | 111 +++++++++-----------------------
 src/spirv/spirv_compression.h   |   6 +-
 2 files changed, 32 insertions(+), 85 deletions(-)

diff --git a/src/spirv/spirv_compression.cpp b/src/spirv/spirv_compression.cpp
index 6c3f68753..27dc8b9ab 100644
--- a/src/spirv/spirv_compression.cpp
+++ b/src/spirv/spirv_compression.cpp
@@ -3,62 +3,27 @@
 namespace dxvk {
 
   SpirvCompressedBuffer::SpirvCompressedBuffer()
-  : m_size(0) {
+  : m_dwords(0) {
 
   }
 
 
   SpirvCompressedBuffer::SpirvCompressedBuffer(
     const SpirvCodeBuffer& code)
-  : m_size(code.dwords()) {
-    const uint32_t* data = code.data();
+  : m_dwords(code.dwords()) {
+    size_t dwords = m_dwords;
+    if (dwords == 0)
+      return;
+
+    const uint32_t *src = code.data();
+    const uint32_t *end = src + dwords;
+    do {
+      uint32_t word = *src++;
+      m_code.push_back(word & 0x7f);
+      while (word >>= 7)
+        m_code.push_back((word & 0x7f) | 0x80);
+    } while (src != end);
 
-    // The compression works by eliminating leading null bytes
-    // from DWORDs, exploiting that SPIR-V IDs are consecutive
-    // integers that usually fall into the 16-bit range. For
-    // each DWORD, a two-bit integer is stored which indicates
-    // the number of bytes it takes in the compressed buffer.
-    // This way, it can achieve a compression ratio of ~50%.
-    m_mask.reserve((m_size + NumMaskWords - 1) / NumMaskWords);
-    m_code.reserve((m_size + 1) / 2);
-
-    uint64_t dstWord  = 0;
-    uint32_t dstShift = 0;
-
-    for (uint32_t i = 0; i < m_size; i += NumMaskWords) {
-      uint64_t byteCounts = 0;
-
-      for (uint32_t w = 0; w < NumMaskWords && i + w < m_size; w++) {
-        uint64_t word = data[i + w];
-        uint64_t bytes = 0;
-
-        if      (word < (1 <<  8)) bytes = 0;
-        else if (word < (1 << 16)) bytes = 1;
-        else if (word < (1 << 24)) bytes = 2;
-        else                       bytes = 3;
-
-        byteCounts |= bytes << (2 * w);
-
-        uint32_t bits = 8 * bytes + 8;
-        uint32_t rem  = bit::pack(dstWord, dstShift, word, bits);
-
-        if (unlikely(rem != 0)) {
-          m_code.push_back(dstWord);
-
-          dstWord  = 0;
-          dstShift = 0;
-
-          bit::pack(dstWord, dstShift, word >> (bits - rem), rem);
-        }
-      }
-
-      m_mask.push_back(byteCounts);
-    }
-
-    if (dstShift)
-      m_code.push_back(dstWord);
-
-    m_mask.shrink_to_fit();
     m_code.shrink_to_fit();
   }
 
@@ -69,40 +34,24 @@ namespace dxvk {
 
 
   SpirvCodeBuffer SpirvCompressedBuffer::decompress() const {
-    SpirvCodeBuffer code(m_size);
-    uint32_t* data = code.data();
-
-    if (m_size == 0)
+    SpirvCodeBuffer code(m_dwords);
+    if (m_dwords == 0)
       return code;
 
-    uint32_t maskIdx = 0;
-    uint32_t codeIdx = 0;
-
-    uint64_t srcWord  = m_code[codeIdx++];
-    uint32_t srcShift = 0;
-
-    for (uint32_t i = 0; i < m_size; i += NumMaskWords) {
-      uint64_t srcMask = m_mask[maskIdx++];
-
-      for (uint32_t w = 0; w < NumMaskWords && i + w < m_size; w++) {
-        uint32_t bits = 8 * ((srcMask & 3) + 1);
-
-        uint64_t word = 0;
-        uint32_t rem = bit::unpack(word, srcWord, srcShift, bits);
-
-        if (unlikely(rem != 0)) {
-          srcWord  = m_code[codeIdx++];
-          srcShift = 0;
-
-          uint64_t tmp = 0;
-          bit::unpack(tmp, srcWord, srcShift, rem);
-          word |= tmp << (bits - rem);
-        }
-
-        data[i + w] = word;
-        srcMask >>= 2;
-      }
-    }
+    uint32_t *dst = code.data();
+    const uint8_t *src = m_code.data();
+    const uint8_t *end = src + m_code.size();
+    do {
+      *dst = *src++;
+      if (src == end || !(*src & 0x80)) continue;
+      *dst |= (*src++ & 0x7f) << 7;
+      if (src == end || !(*src & 0x80)) continue;
+      *dst |= (*src++ & 0x7f) << 14;
+      if (src == end || !(*src & 0x80)) continue;
+      *dst |= (*src++ & 0x7f) << 21;
+      if (src == end || !(*src & 0x80)) continue;
+      *dst |= (*src++ & 0x7f) << 28;
+    } while (++dst, src != end);
 
     return code;
   }
diff --git a/src/spirv/spirv_compression.h b/src/spirv/spirv_compression.h
index 7a1276c8e..72f5e8373 100644
--- a/src/spirv/spirv_compression.h
+++ b/src/spirv/spirv_compression.h
@@ -13,7 +13,6 @@ namespace dxvk {
    * to keep memory footprint low.
    */
   class SpirvCompressedBuffer {
-    constexpr static uint32_t NumMaskWords = 32;
   public:
 
     SpirvCompressedBuffer();
@@ -27,9 +26,8 @@ namespace dxvk {
 
   private:
 
-    uint32_t              m_size;
-    std::vector<uint64_t> m_mask;
-    std::vector<uint64_t> m_code;
+    uint32_t             m_dwords;
+    std::vector<uint8_t> m_code;
 
   };
 

From 32170ec80a017ffbd87d193e6cd5e21ce025b4a6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 18:04:15 +0200
Subject: [PATCH 07/15] [spirv] Introduce SpirvWriter class to factor common
 code

This prepares ground for writing compressed data directly.
---
 src/spirv/spirv_code_buffer.cpp |  68 ----------------
 src/spirv/spirv_code_buffer.h   |  61 +--------------
 src/spirv/spirv_writer.h        | 133 ++++++++++++++++++++++++++++++++
 3 files changed, 135 insertions(+), 127 deletions(-)
 create mode 100644 src/spirv/spirv_writer.h

diff --git a/src/spirv/spirv_code_buffer.cpp b/src/spirv/spirv_code_buffer.cpp
index 74d8dd970..b43a61b65 100644
--- a/src/spirv/spirv_code_buffer.cpp
+++ b/src/spirv/spirv_code_buffer.cpp
@@ -70,68 +70,6 @@ namespace dxvk {
   }
   
   
-  void SpirvCodeBuffer::putIns(spv::Op opCode, uint16_t wordCount) {
-    this->putWord(
-        (static_cast<uint32_t>(opCode)    <<  0)
-      | (static_cast<uint32_t>(wordCount) << 16));
-  }
-  
-  
-  void SpirvCodeBuffer::putInt32(uint32_t word) {
-    this->putWord(word);
-  }
-  
-  
-  void SpirvCodeBuffer::putInt64(uint64_t value) {
-    this->putWord(value >>  0);
-    this->putWord(value >> 32);
-  }
-  
-  
-  void SpirvCodeBuffer::putFloat32(float value) {
-    uint32_t tmp;
-    static_assert(sizeof(tmp) == sizeof(value));
-    std::memcpy(&tmp, &value, sizeof(value));
-    this->putInt32(tmp);
-  }
-  
-  
-  void SpirvCodeBuffer::putFloat64(double value) {
-    uint64_t tmp;
-    static_assert(sizeof(tmp) == sizeof(value));
-    std::memcpy(&tmp, &value, sizeof(value));
-    this->putInt64(tmp);
-  }
-  
-  
-  void SpirvCodeBuffer::putStr(const char* str) {
-    uint32_t word = 0;
-    uint32_t nbit = 0;
-    
-    for (uint32_t i = 0; str[i] != '\0'; str++) {
-      word |= (static_cast<uint32_t>(str[i]) & 0xFF) << nbit;
-      
-      if ((nbit += 8) == 32) {
-        this->putWord(word);
-        word = 0;
-        nbit = 0;
-      }
-    }
-    
-    // Commit current word
-    this->putWord(word);
-  }
-  
-  
-  void SpirvCodeBuffer::putHeader(uint32_t version, uint32_t boundIds) {
-    this->putWord(spv::MagicNumber);
-    this->putWord(version);
-    this->putWord(0); // Generator
-    this->putWord(boundIds);
-    this->putWord(0); // Schema
-  }
-  
-  
   void SpirvCodeBuffer::erase(size_t size) {
     m_code.erase(
       m_code.begin() + m_ptr,
@@ -139,12 +77,6 @@ namespace dxvk {
   }
 
 
-  uint32_t SpirvCodeBuffer::strLen(const char* str) {
-    // Null-termination plus padding
-    return (std::strlen(str) + 4) / 4;
-  }
-  
-  
   void SpirvCodeBuffer::store(std::ostream& stream) const {
     stream.write(
       reinterpret_cast<const char*>(m_code.data()),
diff --git a/src/spirv/spirv_code_buffer.h b/src/spirv/spirv_code_buffer.h
index a06b594c1..aa6423815 100644
--- a/src/spirv/spirv_code_buffer.h
+++ b/src/spirv/spirv_code_buffer.h
@@ -6,6 +6,7 @@
 #include <vector>
 
 #include "spirv_instruction.h"
+#include "spirv_writer.h"
 
 namespace dxvk {
   
@@ -16,7 +17,7 @@ namespace dxvk {
    * Stores arbitrary SPIR-V instructions in a
    * format that can be read by Vulkan drivers.
    */
-  class SpirvCodeBuffer {
+  class SpirvCodeBuffer : public SpirvWriter<SpirvCodeBuffer> {
     
   public:
     
@@ -100,56 +101,6 @@ namespace dxvk {
      * \param [in] word The word to append
      */
     void putWord(uint32_t word);
-    
-    /**
-     * \brief Appends an instruction word to the buffer
-     * 
-     * Adds a single word containing both the word count
-     * and the op code number for a single instruction.
-     * \param [in] opCode Operand code
-     * \param [in] wordCount Number of words
-     */
-    void putIns(spv::Op opCode, uint16_t wordCount);
-
-    /**
-     * \brief Appends a 32-bit integer to the buffer
-     * \param [in] value The number to add
-     */
-    void putInt32(uint32_t word);
-    
-    /**
-     * \brief Appends a 64-bit integer to the buffer
-     * 
-     * A 64-bit integer will take up two 32-bit words.
-     * \param [in] value 64-bit value to add
-     */
-    void putInt64(uint64_t value);
-    
-    /**
-     * \brief Appends a 32-bit float to the buffer
-     * \param [in] value The number to add
-     */
-    void putFloat32(float value);
-    
-    /**
-     * \brief Appends a 64-bit float to the buffer
-     * \param [in] value The number to add
-     */
-    void putFloat64(double value);
-    
-    /**
-     * \brief Appends a literal string to the buffer
-     * \param [in] str String to append to the buffer
-     */
-    void putStr(const char* str);
-    
-    /**
-     * \brief Adds the header to the buffer
-     *
-     * \param [in] version SPIR-V version
-     * \param [in] boundIds Number of bound IDs
-     */
-    void putHeader(uint32_t version, uint32_t boundIds);
 
     /**
      * \brief Erases given number of dwords
@@ -160,14 +111,6 @@ namespace dxvk {
      */
     void erase(size_t size);
     
-    /**
-     * \brief Computes length of a literal string
-     * 
-     * \param [in] str The string to check
-     * \returns Number of words consumed by a string
-     */
-    uint32_t strLen(const char* str);
-    
     /**
      * \brief Stores the SPIR-V module to a stream
      * 
diff --git a/src/spirv/spirv_writer.h b/src/spirv/spirv_writer.h
new file mode 100644
index 000000000..d27b5b18d
--- /dev/null
+++ b/src/spirv/spirv_writer.h
@@ -0,0 +1,133 @@
+#pragma once
+
+#include <spirv/spirv.hpp>
+
+#include "spirv_instruction.h"
+
+namespace dxvk {
+  
+  /**
+   * \brief SPIR-V code buffer
+   * 
+   * Helper class for generating SPIR-V shaders.
+   * Stores arbitrary SPIR-V instructions in a
+   * format that can be read by Vulkan drivers.
+   */
+  template<class SpirvBuffer>
+  class SpirvWriter {
+    
+  public:
+    
+    /**
+     * \brief Appends an 32-bit word to the buffer
+     * \param [in] word The word to append
+     */
+    void putWord(uint32_t word) {
+      static_cast<SpirvBuffer*>(this)->putWord(word);
+    }
+    
+    /**
+     * \brief Appends an instruction word to the buffer
+     * 
+     * Adds a single word containing both the word count
+     * and the op code number for a single instruction.
+     * \param [in] opCode Operand code
+     * \param [in] wordCount Number of words
+     */
+    void putIns(spv::Op opCode, uint16_t wordCount) {
+      this->putWord(
+          (static_cast<uint32_t>(opCode)    <<  0)
+        | (static_cast<uint32_t>(wordCount) << 16));
+    }
+    
+    /**
+     * \brief Appends a 32-bit integer to the buffer
+     * \param [in] value The number to add
+     */
+    void putInt32(uint32_t word) {
+      this->putWord(word);
+    }
+    
+    /**
+     * \brief Appends a 64-bit integer to the buffer
+     * 
+     * A 64-bit integer will take up two 32-bit words.
+     * \param [in] value 64-bit value to add
+     */
+    void putInt64(uint64_t value) {
+      this->putWord(value >>  0);
+      this->putWord(value >> 32);
+    }
+    
+    /**
+     * \brief Appends a 32-bit float to the buffer
+     * \param [in] value The number to add
+     */
+    void putFloat32(float value) {
+      uint32_t tmp;
+      static_assert(sizeof(tmp) == sizeof(value));
+      std::memcpy(&tmp, &value, sizeof(value));
+      this->putInt32(tmp);
+    }
+    
+    /**
+     * \brief Appends a 64-bit float to the buffer
+     * \param [in] value The number to add
+     */
+    void putFloat64(double value) {
+      uint64_t tmp;
+      static_assert(sizeof(tmp) == sizeof(value));
+      std::memcpy(&tmp, &value, sizeof(value));
+      this->putInt64(tmp);
+    }
+    
+    /**
+     * \brief Appends a literal string to the buffer
+     * \param [in] str String to append to the buffer
+     */
+    void putStr(const char* str) {
+      uint32_t word = 0;
+      uint32_t nbit = 0;
+      
+      for (uint32_t i = 0; str[i] != '\0'; str++) {
+        word |= (static_cast<uint32_t>(str[i]) & 0xFF) << nbit;
+        
+        if ((nbit += 8) == 32) {
+          this->putWord(word);
+          word = 0;
+          nbit = 0;
+        }
+      }
+      
+      // Commit current word
+      this->putWord(word);
+    }
+    
+    /**
+     * \brief Adds the header to the buffer
+     *
+     * \param [in] version SPIR-V version
+     * \param [in] boundIds Number of bound IDs
+     */
+    void putHeader(uint32_t version, uint32_t boundIds) {
+      this->putWord(spv::MagicNumber);
+      this->putWord(version);
+      this->putWord(0); // Generator
+      this->putWord(boundIds);
+      this->putWord(0); // Schema
+    }
+    
+    /**
+     * \brief Computes length of a literal string
+     * 
+     * \param [in] str The string to check
+     * \returns Number of words consumed by a string
+     */
+    uint32_t strLen(const char* str)  {
+      // Null-termination plus padding
+      return (std::strlen(str) + 4) / 4;
+    }
+
+  };
+  
+}

From 5825ef2fee2c081ebd25fd828a371f7ce6c38d07 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 16 Apr 2020 17:55:37 +0200
Subject: [PATCH 08/15] [spirv] Track enabled capabilities instead of looking
 them up

---
 src/spirv/spirv_module.cpp | 7 ++-----
 src/spirv/spirv_module.h   | 1 +
 2 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/src/spirv/spirv_module.cpp b/src/spirv/spirv_module.cpp
index b66823985..f7bcf7c35 100644
--- a/src/spirv/spirv_module.cpp
+++ b/src/spirv/spirv_module.cpp
@@ -42,13 +42,10 @@ namespace dxvk {
           spv::Capability         capability) {
     // Scan the generated instructions to check
     // whether we already enabled the capability.
-    for (auto ins : m_capabilities) {
-      if (ins.opCode() == spv::OpCapability && ins.arg(1) == capability)
-        return;
-    }
-    
+    if (m_enabledCaps.find(capability) != m_enabledCaps.end()) return;
     m_capabilities.putIns (spv::OpCapability, 2);
     m_capabilities.putWord(capability);
+    m_enabledCaps.insert(capability);
   }
   
   
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index a453f2740..7afba2a82 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -1225,6 +1225,7 @@ namespace dxvk {
     SpirvCodeBuffer m_variables;
     SpirvCodeBuffer m_code;
 
+    std::unordered_set<spv::Capability>  m_enabledCaps;
     std::vector<size_t> m_typeLocs;
     std::vector<size_t> m_constLocs;
 

From ce555c3eac34fd7bd64c4a80e0520820c87be16f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 18:59:25 +0200
Subject: [PATCH 09/15] [spirv] Track enabled execution modes

---
 src/spirv/spirv_module.cpp | 1 +
 src/spirv/spirv_module.h   | 4 +++-
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/spirv/spirv_module.cpp b/src/spirv/spirv_module.cpp
index f7bcf7c35..9c715c69e 100644
--- a/src/spirv/spirv_module.cpp
+++ b/src/spirv/spirv_module.cpp
@@ -87,6 +87,7 @@ namespace dxvk {
     m_execModeInfo.putIns (spv::OpExecutionMode, 3);
     m_execModeInfo.putWord(entryPointId);
     m_execModeInfo.putWord(executionMode);
+    m_enabledModes.insert(executionMode);
   }
   
   
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index 7afba2a82..e37b24ac8 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -1225,7 +1225,9 @@ namespace dxvk {
     SpirvCodeBuffer m_variables;
     SpirvCodeBuffer m_code;
 
-    std::unordered_set<spv::Capability>  m_enabledCaps;
+    std::unordered_set<spv::Capability>    m_enabledCaps;
+    std::unordered_set<spv::ExecutionMode> m_enabledModes;
+
     std::vector<size_t> m_typeLocs;
     std::vector<size_t> m_constLocs;
 

From 16b91f17d7c06724761f1d68eb429379ff99db6c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 16 Apr 2020 18:13:39 +0200
Subject: [PATCH 10/15] [spirv] Return compressed buffer from
 SpirvModule::compile

---
 src/d3d9/d3d9_fixed_function.cpp |  4 ++
 src/d3d9/d3d9_swvp_emu.cpp       |  4 ++
 src/dxbc/dxbc_compiler.cpp       |  4 ++
 src/dxso/dxso_compiler.cpp       |  4 ++
 src/dxvk/dxvk_shader.cpp         | 78 +++++++++++++++++++++++---------
 src/dxvk/dxvk_shader.h           | 17 +++++--
 src/spirv/spirv_module.cpp       |  4 +-
 src/spirv/spirv_module.h         | 23 +++++++++-
 8 files changed, 110 insertions(+), 28 deletions(-)

diff --git a/src/d3d9/d3d9_fixed_function.cpp b/src/d3d9/d3d9_fixed_function.cpp
index b4c459fce..ea2ee9ae3 100644
--- a/src/d3d9/d3d9_fixed_function.cpp
+++ b/src/d3d9/d3d9_fixed_function.cpp
@@ -707,6 +707,10 @@ namespace dxvk {
       m_resourceSlots.data(),
       m_interfaceSlots,
       m_module.compile(),
+      m_module.exportsStencil(),
+      m_module.hasTransformFeedback(),
+      m_module.hasSampleRateShading(),
+      m_module.exportsViewportIndex(),
       shaderOptions,
       std::move(constData));
   }
diff --git a/src/d3d9/d3d9_swvp_emu.cpp b/src/d3d9/d3d9_swvp_emu.cpp
index cd45a1c0c..1e683c85b 100644
--- a/src/d3d9/d3d9_swvp_emu.cpp
+++ b/src/d3d9/d3d9_swvp_emu.cpp
@@ -291,6 +291,10 @@ namespace dxvk {
         m_resourceSlots.data(),
         m_interfaceSlots,
         m_module.compile(),
+        m_module.exportsStencil(),
+        m_module.hasTransformFeedback(),
+        m_module.hasSampleRateShading(),
+        m_module.exportsViewportIndex(),
         DxvkShaderOptions(),
         std::move(constData));
     }
diff --git a/src/dxbc/dxbc_compiler.cpp b/src/dxbc/dxbc_compiler.cpp
index bc19e8772..748f8e9bd 100644
--- a/src/dxbc/dxbc_compiler.cpp
+++ b/src/dxbc/dxbc_compiler.cpp
@@ -260,6 +260,10 @@ namespace dxvk {
       m_resourceSlots.data(),
       m_interfaceSlots,
       m_module.compile(),
+      m_module.exportsStencil(),
+      m_module.hasTransformFeedback(),
+      m_module.hasSampleRateShading(),
+      m_module.exportsViewportIndex(),
       shaderOptions,
       std::move(m_immConstData));
   }
diff --git a/src/dxso/dxso_compiler.cpp b/src/dxso/dxso_compiler.cpp
index 0e5fa38cf..fdacc74ec 100644
--- a/src/dxso/dxso_compiler.cpp
+++ b/src/dxso/dxso_compiler.cpp
@@ -251,6 +251,10 @@ namespace dxvk {
       m_resourceSlots.data(),
       m_interfaceSlots,
       m_module.compile(),
+      m_module.exportsStencil(),
+      m_module.hasTransformFeedback(),
+      m_module.hasSampleRateShading(),
+      m_module.exportsViewportIndex(),
       shaderOptions,
       std::move(constData));
   }
diff --git a/src/dxvk/dxvk_shader.cpp b/src/dxvk/dxvk_shader.cpp
index cfe822af1..ac1d84f96 100644
--- a/src/dxvk/dxvk_shader.cpp
+++ b/src/dxvk/dxvk_shader.cpp
@@ -110,25 +110,7 @@ namespace dxvk {
     for (uint32_t i = 0; i < slotCount; i++)
       m_slots.push_back(slotInfos[i]);
     
-    // Gather the offsets where the binding IDs
-    // are stored so we can quickly remap them.
-    uint32_t o1VarId = 0;
-    
     for (auto ins : code) {
-      if (ins.opCode() == spv::OpDecorate) {
-        if (ins.arg(2) == spv::DecorationBinding
-         || ins.arg(2) == spv::DecorationSpecId)
-          m_idOffsets.push_back(ins.offset() + 3);
-        
-        if (ins.arg(2) == spv::DecorationLocation && ins.arg(3) == 1) {
-          m_o1LocOffset = ins.offset() + 3;
-          o1VarId = ins.arg(1);
-        }
-        
-        if (ins.arg(2) == spv::DecorationIndex && ins.arg(1) == o1VarId)
-          m_o1IdxOffset = ins.offset() + 3;
-      }
-
       if (ins.opCode() == spv::OpExecutionMode) {
         if (ins.arg(2) == spv::ExecutionModeStencilRefReplacingEXT)
           m_flags.set(DxvkShaderFlag::ExportsStencilRef);
@@ -146,6 +128,38 @@ namespace dxvk {
       }
     }
   }
+
+
+  DxvkShader::DxvkShader(
+          VkShaderStageFlagBits   stage,
+          uint32_t                slotCount,
+    const DxvkResourceSlot*       slotInfos,
+    const DxvkInterfaceSlots&     iface,
+          SpirvCompressedBuffer   code,
+          bool                    exportsStencil,
+          bool                    hasTransformFeedback,
+          bool                    hasSampleRateShading,
+          bool                    exportsViewportIndex,
+    const DxvkShaderOptions&      options,
+          DxvkShaderConstData&&   constData)
+  : m_stage(stage), m_code(std::move(code)), m_interface(iface),
+    m_options(options), m_constData(std::move(constData)) {
+    // Write back resource slot infos
+    for (uint32_t i = 0; i < slotCount; i++)
+      m_slots.push_back(slotInfos[i]);
+
+    if (exportsStencil)
+      m_flags.set(DxvkShaderFlag::ExportsStencilRef);
+
+    if (hasTransformFeedback)
+      m_flags.set(DxvkShaderFlag::HasTransformFeedback);
+
+    if (hasSampleRateShading)
+      m_flags.set(DxvkShaderFlag::HasSampleRateShading);
+
+    if (exportsViewportIndex)
+      m_flags.set(DxvkShaderFlag::ExportsViewportIndexLayerFromVertexStage);
+  }
   
   
   DxvkShader::~DxvkShader() {
@@ -173,16 +187,38 @@ namespace dxvk {
     SpirvCodeBuffer spirvCode = m_code.decompress();
     uint32_t* code = spirvCode.data();
     
+    // Gather the offsets where the binding IDs
+    // are stored so we can quickly remap them.
+    uint32_t o1VarId = 0;
+    size_t o1IdxOffset = 0;
+    size_t o1LocOffset = 0;
+    std::vector<size_t> idOffsets;
+    for (auto ins : spirvCode) {
+      if (ins.opCode() == spv::OpDecorate) {
+        if (ins.arg(2) == spv::DecorationBinding
+         || ins.arg(2) == spv::DecorationSpecId)
+          idOffsets.push_back(ins.offset() + 3);
+        
+        if (ins.arg(2) == spv::DecorationLocation && ins.arg(3) == 1) {
+          o1LocOffset = ins.offset() + 3;
+          o1VarId = ins.arg(1);
+        }
+        
+        if (ins.arg(2) == spv::DecorationIndex && ins.arg(1) == o1VarId)
+          o1IdxOffset = ins.offset() + 3;
+      }
+    }
+
     // Remap resource binding IDs
-    for (uint32_t ofs : m_idOffsets) {
+    for (uint32_t ofs : idOffsets) {
       if (code[ofs] < MaxNumResourceSlots)
         code[ofs] = mapping.getBindingId(code[ofs]);
     }
 
     // For dual-source blending we need to re-map
     // location 1, index 0 to location 0, index 1
-    if (info.fsDualSrcBlend && m_o1IdxOffset && m_o1LocOffset)
-      std::swap(code[m_o1IdxOffset], code[m_o1LocOffset]);
+    if (info.fsDualSrcBlend && o1IdxOffset && o1LocOffset)
+      std::swap(code[o1IdxOffset], code[o1LocOffset]);
     
     // Replace undefined input variables with zero
     for (uint32_t u = info.undefinedInputs; u; u &= u - 1)
diff --git a/src/dxvk/dxvk_shader.h b/src/dxvk/dxvk_shader.h
index 065da8a4c..a68b5eefc 100644
--- a/src/dxvk/dxvk_shader.h
+++ b/src/dxvk/dxvk_shader.h
@@ -147,6 +147,19 @@ namespace dxvk {
       const DxvkShaderOptions&      options,
             DxvkShaderConstData&&   constData);
     
+    DxvkShader(
+            VkShaderStageFlagBits   stage,
+            uint32_t                slotCount,
+      const DxvkResourceSlot*       slotInfos,
+      const DxvkInterfaceSlots&     iface,
+            SpirvCompressedBuffer   code,
+            bool                    exportsStencil,
+            bool                    hasTransformFeedback,
+            bool                    hasSampleRateShading,
+            bool                    exportsViewportIndex,
+      const DxvkShaderOptions&      options,
+            DxvkShaderConstData&&   constData);
+    
     ~DxvkShader();
     
     /**
@@ -283,7 +296,6 @@ namespace dxvk {
     SpirvCompressedBuffer m_code;
     
     std::vector<DxvkResourceSlot> m_slots;
-    std::vector<size_t>           m_idOffsets;
     DxvkInterfaceSlots            m_interface;
     DxvkShaderFlags               m_flags;
     DxvkShaderOptions             m_options;
@@ -291,9 +303,6 @@ namespace dxvk {
     DxvkShaderKey                 m_key;
     size_t                        m_hash = 0;
 
-    size_t m_o1IdxOffset = 0;
-    size_t m_o1LocOffset = 0;
-
     static void eliminateInput(SpirvCodeBuffer& code, uint32_t location);
 
   };
diff --git a/src/spirv/spirv_module.cpp b/src/spirv/spirv_module.cpp
index 9c715c69e..836b6a3aa 100644
--- a/src/spirv/spirv_module.cpp
+++ b/src/spirv/spirv_module.cpp
@@ -15,7 +15,7 @@ namespace dxvk {
   }
   
   
-  SpirvCodeBuffer SpirvModule::compile() const {
+  SpirvCompressedBuffer SpirvModule::compile() const {
     SpirvCodeBuffer result;
     result.putHeader(m_version, m_id);
     result.append(m_capabilities);
@@ -29,7 +29,7 @@ namespace dxvk {
     result.append(m_typeConstDefs);
     result.append(m_variables);
     result.append(m_code);
-    return result;
+    return SpirvCompressedBuffer(result);
   }
   
   
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index e37b24ac8..394179794 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -3,6 +3,7 @@
 #include <unordered_set>
 
 #include "spirv_code_buffer.h"
+#include "spirv_compression.h"
 
 namespace dxvk {
   
@@ -49,7 +50,7 @@ namespace dxvk {
 
     ~SpirvModule();
     
-    SpirvCodeBuffer compile() const;
+    SpirvCompressedBuffer compile() const;
     
     size_t getInsertionPtr() {
       return m_code.getInsertionPtr();
@@ -1207,6 +1208,26 @@ namespace dxvk {
     void opEndPrimitive(
             uint32_t                streamId);
     
+    bool exportsStencil() {
+      return m_enabledModes.find(spv::ExecutionModeStencilRefReplacingEXT) !=
+        m_enabledModes.end();
+    }
+
+    bool hasTransformFeedback() {
+      return m_enabledModes.find(spv::ExecutionModeXfb) !=
+        m_enabledModes.end();
+    }
+
+    bool hasSampleRateShading() {
+      return m_enabledCaps.find(spv::CapabilitySampleRateShading) !=
+        m_enabledCaps.end();
+    }
+    
+    bool exportsViewportIndex() {
+      return m_enabledCaps.find(spv::CapabilityShaderViewportIndexLayerEXT) !=
+        m_enabledCaps.end();
+    }
+
   private:
     
     uint32_t m_version;

From 9b2d6b24b0c7f0095e32d3026dd5455468c9f450 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 18:50:26 +0200
Subject: [PATCH 11/15] [spirv] Write compressed data directly if possible

---
 src/spirv/spirv_compression.h | 42 ++++++++++++++++++++++++++++++++++-
 src/spirv/spirv_module.cpp    |  5 +++--
 src/spirv/spirv_module.h      | 22 +++++++++---------
 3 files changed, 55 insertions(+), 14 deletions(-)

diff --git a/src/spirv/spirv_compression.h b/src/spirv/spirv_compression.h
index 72f5e8373..1d5727074 100644
--- a/src/spirv/spirv_compression.h
+++ b/src/spirv/spirv_compression.h
@@ -12,7 +12,7 @@ namespace dxvk {
    * Implements a fast in-memory compression
    * to keep memory footprint low.
    */
-  class SpirvCompressedBuffer {
+  class SpirvCompressedBuffer : public SpirvWriter<SpirvCompressedBuffer> {
   public:
 
     SpirvCompressedBuffer();
@@ -22,6 +22,46 @@ namespace dxvk {
     
     ~SpirvCompressedBuffer();
     
+    void shrink() { m_code.shrink_to_fit(); }
+
+    /**
+     * \brief Code size, in dwords
+     * \returns Code size, in dwords
+     */
+    uint32_t dwords() const { return m_dwords; }
+
+    /**
+     * \brief Code size, in bytes
+     * \returns Code size, in bytes
+     */
+    size_t size() const { return m_code.size(); }
+
+    /**
+     * \brief Appends an 32-bit word to the buffer
+     * \param [in] word The word to append
+     */
+    void putWord(uint32_t word) {
+      m_code.push_back(word & 0x7f);
+      while (word >>= 7)
+        m_code.push_back((word & 0x7f) | 0x80);
+      m_dwords += 1;
+    }
+
+    /**
+     * \brief Merges two code buffers
+     *
+     * This is useful to generate declarations or
+     * the SPIR-V header at the same time as the
+     * code when doing so in advance is impossible.
+     * \param [in] other Code buffer to append
+     */
+    void append(const SpirvCompressedBuffer& other) {
+      m_code.insert(m_code.end(),
+                    other.m_code.begin(),
+                    other.m_code.end());
+      m_dwords += other.dwords();
+    }
+
     SpirvCodeBuffer decompress() const;
 
   private:
diff --git a/src/spirv/spirv_module.cpp b/src/spirv/spirv_module.cpp
index 836b6a3aa..6127fedbd 100644
--- a/src/spirv/spirv_module.cpp
+++ b/src/spirv/spirv_module.cpp
@@ -16,7 +16,7 @@ namespace dxvk {
   
   
   SpirvCompressedBuffer SpirvModule::compile() const {
-    SpirvCodeBuffer result;
+    SpirvCompressedBuffer result;
     result.putHeader(m_version, m_id);
     result.append(m_capabilities);
     result.append(m_extensions);
@@ -29,7 +29,8 @@ namespace dxvk {
     result.append(m_typeConstDefs);
     result.append(m_variables);
     result.append(m_code);
-    return SpirvCompressedBuffer(result);
+    result.shrink();
+    return result;
   }
   
   
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index 394179794..f81a1be80 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -1234,17 +1234,17 @@ namespace dxvk {
     uint32_t m_id             = 1;
     uint32_t m_instExtGlsl450 = 0;
     
-    SpirvCodeBuffer m_capabilities;
-    SpirvCodeBuffer m_extensions;
-    SpirvCodeBuffer m_instExt;
-    SpirvCodeBuffer m_memoryModel;
-    SpirvCodeBuffer m_entryPoints;
-    SpirvCodeBuffer m_execModeInfo;
-    SpirvCodeBuffer m_debugNames;
-    SpirvCodeBuffer m_annotations;
-    SpirvCodeBuffer m_typeConstDefs;
-    SpirvCodeBuffer m_variables;
-    SpirvCodeBuffer m_code;
+    SpirvCompressedBuffer m_capabilities;
+    SpirvCompressedBuffer m_extensions;
+    SpirvCompressedBuffer m_instExt;
+    SpirvCompressedBuffer m_memoryModel;
+    SpirvCompressedBuffer m_entryPoints;
+    SpirvCompressedBuffer m_execModeInfo;
+    SpirvCompressedBuffer m_debugNames;
+    SpirvCompressedBuffer m_annotations;
+    SpirvCodeBuffer       m_typeConstDefs;
+    SpirvCodeBuffer       m_variables;
+    SpirvCodeBuffer       m_code;
 
     std::unordered_set<spv::Capability>    m_enabledCaps;
     std::unordered_set<spv::ExecutionMode> m_enabledModes;

From 1e136de8fbb7cd6f35e5592c3539212a425b33de Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 16:20:58 +0200
Subject: [PATCH 12/15] [spirv] Optimize SpirvCodeBuffer insertion

Instead of inserting on every write, use a temporary buffer and insert
it fully when insertion stops. For even more efficiency, swap the code
and insert buffers during insertion mode to save a branch in putWord.
---
 src/spirv/spirv_code_buffer.cpp | 33 +++++++++++++++------------------
 src/spirv/spirv_code_buffer.h   | 26 ++++++++++++++++++--------
 2 files changed, 33 insertions(+), 26 deletions(-)

diff --git a/src/spirv/spirv_code_buffer.cpp b/src/spirv/spirv_code_buffer.cpp
index b43a61b65..9d5e2aed7 100644
--- a/src/spirv/spirv_code_buffer.cpp
+++ b/src/spirv/spirv_code_buffer.cpp
@@ -9,14 +9,12 @@ namespace dxvk {
   SpirvCodeBuffer::~SpirvCodeBuffer() { }
   
   
-  SpirvCodeBuffer::SpirvCodeBuffer(uint32_t size)
-  : m_ptr(size) {
+  SpirvCodeBuffer::SpirvCodeBuffer(uint32_t size) {
     m_code.resize(size);
   }
 
 
-  SpirvCodeBuffer::SpirvCodeBuffer(uint32_t size, const uint32_t* data)
-  : m_ptr(size) {
+  SpirvCodeBuffer::SpirvCodeBuffer(uint32_t size, const uint32_t* data) {
     m_code.resize(size);
     std::memcpy(m_code.data(), data, size * sizeof(uint32_t));
   }
@@ -35,18 +33,20 @@ namespace dxvk {
     m_code.resize(buffer.size() / sizeof(uint32_t));
     std::memcpy(reinterpret_cast<char*>(m_code.data()),
       buffer.data(), m_code.size() * sizeof(uint32_t));
-    
-    m_ptr = m_code.size();
   }
   
   
   uint32_t SpirvCodeBuffer::allocId() {
     constexpr size_t BoundIdsOffset = 3;
 
-    if (m_code.size() <= BoundIdsOffset)
+    if (this->dwords() <= BoundIdsOffset)
       return 0;
 
-    return m_code[BoundIdsOffset]++;
+    // If we are inserting, the buffers are swapped
+    if (m_ptr == not_inserting)
+      return m_code[BoundIdsOffset]++;
+    else
+      return m_insert[BoundIdsOffset]++;
   }
 
 
@@ -59,21 +59,18 @@ namespace dxvk {
       const uint32_t* src = other.m_code.data();
       
       std::memcpy(dst + size, src, other.size());
-      m_ptr += other.m_code.size();
     }
   }
   
   
-  void SpirvCodeBuffer::putWord(uint32_t word) {
-    m_code.insert(m_code.begin() + m_ptr, word);
-    m_ptr += 1;
-  }
-  
-  
   void SpirvCodeBuffer::erase(size_t size) {
-    m_code.erase(
-      m_code.begin() + m_ptr,
-      m_code.begin() + m_ptr + size);
+    if (m_ptr == not_inserting)
+      return;
+
+    // If we are inserting, the buffers are swapped
+    m_insert.erase(
+      m_insert.begin() + m_ptr,
+      m_insert.begin() + m_ptr + size);
   }
 
 
diff --git a/src/spirv/spirv_code_buffer.h b/src/spirv/spirv_code_buffer.h
index aa6423815..53e930184 100644
--- a/src/spirv/spirv_code_buffer.h
+++ b/src/spirv/spirv_code_buffer.h
@@ -18,7 +18,8 @@ namespace dxvk {
    * format that can be read by Vulkan drivers.
    */
   class SpirvCodeBuffer : public SpirvWriter<SpirvCodeBuffer> {
-    
+    static constexpr size_t not_inserting = ~(size_t)0;
+
   public:
     
     SpirvCodeBuffer();
@@ -44,7 +45,7 @@ namespace dxvk {
      * \returns Code size, in dwords
      */
     uint32_t dwords() const {
-      return m_code.size();
+      return m_code.size() + m_insert.size();
     }
     
     /**
@@ -52,7 +53,7 @@ namespace dxvk {
      * \returns Code size, in bytes
      */
     size_t size() const {
-      return m_code.size() * sizeof(uint32_t);
+      return this->dwords() * sizeof(uint32_t);
     }
     
     /**
@@ -100,7 +101,9 @@ namespace dxvk {
      * \brief Appends an 32-bit word to the buffer
      * \param [in] word The word to append
      */
-    void putWord(uint32_t word);
+    void putWord(uint32_t word) {
+      m_code.push_back(word);
+    }
 
     /**
      * \brief Erases given number of dwords
@@ -131,7 +134,7 @@ namespace dxvk {
      * \returns Current instruction pointr
      */
     size_t getInsertionPtr() const {
-      return m_ptr;
+      return m_code.size();
     }
     
     /**
@@ -142,6 +145,7 @@ namespace dxvk {
      * \returns Current instruction pointr
      */
     void beginInsertion(size_t ptr) {
+      std::swap(m_code, m_insert);
       m_ptr = ptr;
     }
     
@@ -153,14 +157,20 @@ namespace dxvk {
      * this will restore default behaviour.
      */
     void endInsertion() {
-      m_ptr = m_code.size();
+      std::swap(m_code, m_insert);
+      m_code.insert(m_code.begin() + m_ptr,
+                    m_insert.begin(),
+                    m_insert.end());
+      m_insert.clear();
+      m_ptr = not_inserting;
     }
     
   private:
     
     std::vector<uint32_t> m_code;
-    size_t m_ptr = 0;
+    std::vector<uint32_t> m_insert;
+    size_t m_ptr = not_inserting;
     
   };
   
-}
\ No newline at end of file
+}

From d6b2beabf1f61b525c284ea5be824a8a1a3c69d1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 19:04:55 +0200
Subject: [PATCH 13/15] [spirv] Implement SpirvCompressedBuffer insertion

---
 src/spirv/spirv_compression.h | 48 ++++++++++++++++++++++++++++++++++-
 src/spirv/spirv_module.h      |  4 +--
 2 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/src/spirv/spirv_compression.h b/src/spirv/spirv_compression.h
index 1d5727074..f6b4aa8b2 100644
--- a/src/spirv/spirv_compression.h
+++ b/src/spirv/spirv_compression.h
@@ -13,6 +13,8 @@ namespace dxvk {
    * to keep memory footprint low.
    */
   class SpirvCompressedBuffer : public SpirvWriter<SpirvCompressedBuffer> {
+    static constexpr size_t not_inserting = ~(size_t)0;
+
   public:
 
     SpirvCompressedBuffer();
@@ -34,7 +36,7 @@ namespace dxvk {
      * \brief Code size, in bytes
      * \returns Code size, in bytes
      */
-    size_t size() const { return m_code.size(); }
+    size_t size() const { return m_code.size() + m_insert.size(); }
 
     /**
      * \brief Appends an 32-bit word to the buffer
@@ -62,12 +64,56 @@ namespace dxvk {
       m_dwords += other.dwords();
     }
 
+    /**
+     * \brief Retrieves current insertion pointer
+     *
+     * Sometimes it may be necessay to insert code into the
+     * middle of the stream rather than appending it. This
+     * retrieves the current function pointer. Note that the
+     * pointer will become invalid if any code is inserted
+     * before the current pointer location.
+     * \returns Current instruction pointr
+     */
+    size_t getInsertionPtr() const {
+      return m_code.size();
+    }
+
+    /**
+     * \brief Sets insertion pointer to a specific value
+     *
+     * Sets the insertion pointer to a value that was
+     * previously retrieved by \ref getInsertionPtr.
+     * \returns Current instruction pointr
+     */
+    void beginInsertion(size_t ptr) {
+      std::swap(m_code, m_insert);
+      m_ptr = ptr;
+    }
+
+    /**
+     * \brief Sets insertion pointer to the end
+     *
+     * After this call, new instructions will be
+     * appended to the stream. In other words,
+     * this will restore default behaviour.
+     */
+    void endInsertion() {
+      std::swap(m_code, m_insert);
+      m_code.insert(m_code.begin() + m_ptr,
+                    m_insert.begin(),
+                    m_insert.end());
+      m_insert.clear();
+      m_ptr = not_inserting;
+    }
+
     SpirvCodeBuffer decompress() const;
 
   private:
 
     uint32_t             m_dwords;
     std::vector<uint8_t> m_code;
+    std::vector<uint8_t> m_insert;
+    size_t m_ptr = not_inserting;
 
   };
 
diff --git a/src/spirv/spirv_module.h b/src/spirv/spirv_module.h
index f81a1be80..e52aa476e 100644
--- a/src/spirv/spirv_module.h
+++ b/src/spirv/spirv_module.h
@@ -1243,8 +1243,8 @@ namespace dxvk {
     SpirvCompressedBuffer m_debugNames;
     SpirvCompressedBuffer m_annotations;
     SpirvCodeBuffer       m_typeConstDefs;
-    SpirvCodeBuffer       m_variables;
-    SpirvCodeBuffer       m_code;
+    SpirvCompressedBuffer m_variables;
+    SpirvCompressedBuffer m_code;
 
     std::unordered_set<spv::Capability>    m_enabledCaps;
     std::unordered_set<spv::ExecutionMode> m_enabledModes;

From c2aac8dfefce06e884b4190922ede288b85f43dd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 17 Apr 2020 10:38:17 +0200
Subject: [PATCH 14/15] [util] Introduce raw_vector with uninitialized storage

---
 src/util/util_raw_vector.h | 137 +++++++++++++++++++++++++++++++++++++
 1 file changed, 137 insertions(+)
 create mode 100644 src/util/util_raw_vector.h

diff --git a/src/util/util_raw_vector.h b/src/util/util_raw_vector.h
new file mode 100644
index 000000000..a54270c84
--- /dev/null
+++ b/src/util/util_raw_vector.h
@@ -0,0 +1,137 @@
+#pragma once
+
+#include <type_traits>
+#include <memory>
+
+namespace dxvk {
+
+  /**
+   * \brief Uninitialized vector
+   *
+   * Implements a vector with uinitialized storage to avoid
+   * std::vector default initialization.
+   */
+  template<typename T>
+  class raw_vector {
+    struct deleter {
+      void operator()(void* p) const { std::free(p); }
+    };
+    using pointer_type = std::unique_ptr<T, deleter>;
+
+  public:
+
+    void reserve(size_t n) {
+      n = pick_capacity(n);
+      if (n > m_capacity)
+        reallocate(n);
+    }
+
+    void shrink_to_fit() {
+      size_t n = pick_capacity(m_size);
+      reallocate(n);
+    }
+
+    void resize(size_t n) {
+      if (n >= m_size) {
+        reserve(n);
+        std::uninitialized_default_construct(ptr(m_size), ptr(n));
+      }
+      m_size = n;
+    }
+
+    void push_back(const T& object) {
+      reserve(m_size + 1);
+      *ptr(m_size++) = object;
+    }
+
+    void push_back(T&& object) {
+      reserve(m_size + 1);
+      *ptr(m_size++) = std::move(object);
+    }
+
+    template<typename... Args>
+    void emplace_back(Args... args) {
+      reserve(m_size + 1);
+      *ptr(m_size++) = T(std::forward<Args>(args)...);
+    }
+
+    void erase(size_t idx) {
+      if (idx < m_size)
+        std::memmove(ptr(idx), ptr(idx + 1), (m_size - idx) * sizeof(T));
+      m_size -= 1;
+    }
+
+    void insert(const T* pos, const T* begin, const T* end) {
+      if (begin == end)
+        return;
+
+      size_t off = pos - ptr(0);
+      size_t size = m_size;
+      size_t count = (end - begin);
+      resize(size + count);
+
+      if (off < size)
+        std::memmove(ptr(off) + count, ptr(off),
+                     (size - off) * sizeof(T));
+      std::memcpy(ptr(off), begin, count * sizeof(T));
+    }
+
+    void pop_back() { m_size--; }
+
+    void clear() { m_size = 0; }
+
+    size_t size() const { return m_size; }
+
+    const T* data() const { return ptr(0); }
+          T* data()       { return ptr(0); }
+
+    const T* begin() const { return ptr(0); }
+          T* begin()       { return ptr(0); }
+
+    const T* end() const { return ptr(m_size); }
+          T* end()       { return ptr(m_size); }
+
+          T& operator [] (size_t idx)       { return *ptr(idx); }
+    const T& operator [] (size_t idx) const { return *ptr(idx); }
+
+          T& front()       { return *ptr(0); }
+    const T& front() const { return *ptr(0); }
+
+          T& back()       { return *ptr(m_size - 1); }
+    const T& back() const { return *ptr(m_size - 1); }
+
+  private:
+
+    pointer_type m_ptr = nullptr;
+    size_t       m_size = 0;
+    size_t       m_capacity = 0;
+
+    size_t pick_capacity(size_t n) {
+      size_t capacity = m_capacity;
+      if (capacity < 128)
+        capacity = 128;
+
+      while (capacity < n)
+        capacity *= 2;
+
+      return capacity;
+    }
+
+    void reallocate(size_t n) {
+      void* ptr = std::realloc(m_ptr.get(), n * sizeof(T));
+      m_ptr.release();
+      m_ptr.reset(static_cast<T*>(ptr));
+      m_capacity = n;
+    }
+
+    T* ptr(size_t idx) {
+      return reinterpret_cast<T*>(m_ptr.get()) + idx;
+    }
+
+    const T* ptr(size_t idx) const {
+      return reinterpret_cast<const T*>(m_ptr.get()) + idx;
+    }
+
+  };
+
+}

From dfa777be4f8fe5ebcc447348b7a4a19742d2005f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 17 Apr 2020 23:55:13 +0200
Subject: [PATCH 15/15] [spirv] Use raw_vector in SpirvCompressedBuffer

---
 src/spirv/spirv_compression.h | 24 +++++++++++++++++-------
 1 file changed, 17 insertions(+), 7 deletions(-)

diff --git a/src/spirv/spirv_compression.h b/src/spirv/spirv_compression.h
index f6b4aa8b2..b4bf82bf5 100644
--- a/src/spirv/spirv_compression.h
+++ b/src/spirv/spirv_compression.h
@@ -4,6 +4,8 @@
 
 #include "spirv_code_buffer.h"
 
+#include "../util/util_raw_vector.h"
+
 namespace dxvk {
 
   /**
@@ -21,6 +23,9 @@ namespace dxvk {
 
     SpirvCompressedBuffer(
       const SpirvCodeBuffer&  code);
+
+    SpirvCompressedBuffer(
+      SpirvCompressedBuffer&& other) = default;
     
     ~SpirvCompressedBuffer();
     
@@ -43,9 +48,14 @@ namespace dxvk {
      * \param [in] word The word to append
      */
     void putWord(uint32_t word) {
-      m_code.push_back(word & 0x7f);
-      while (word >>= 7)
-        m_code.push_back((word & 0x7f) | 0x80);
+      size_t size = m_code.size();
+      m_code.resize(size + 5);
+
+      uint8_t *dst = m_code.data() + size;
+      *dst++ = word & 0x7f;
+      while (word >>= 7) *dst++ = (word & 0x7f) | 0x80;
+      m_code.resize(dst - m_code.data());
+
       m_dwords += 1;
     }
 
@@ -110,11 +120,11 @@ namespace dxvk {
 
   private:
 
-    uint32_t             m_dwords;
-    std::vector<uint8_t> m_code;
-    std::vector<uint8_t> m_insert;
+    uint32_t            m_dwords;
+    raw_vector<uint8_t> m_code;
+    raw_vector<uint8_t> m_insert;
     size_t m_ptr = not_inserting;
 
   };
 
-}
\ No newline at end of file
+}
